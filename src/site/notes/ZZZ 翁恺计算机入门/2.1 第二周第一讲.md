---
{"tags":["翁恺","变量","scanf","int","分隔","格式化字符串","printf","常量","const","浮点数","关键字","scanf_s"],"dg-publish":true,"permalink":"/ZZZ 翁恺计算机入门/2.1 第二周第一讲/","dgPassFrontmatter":true,"created":"2024-04-17T22:52:29.495+02:00","updated":"2024-07-17T20:13:09.424+02:00"}
---

### 2.1.2 变量定义 ：变量是做什么的

我们通过编程一个找零程序来理解变量的定义。这个程序会比单纯的 printf 程序多一些需求：
1. <u>有地方</u>在终端输入数字              
2. <u>有办法</u>在终端输入数字                 
3. 让输入的数字<u>参与计算</u>     

代码如下<font size=2>（不包含结构框架，今后也都不包含）</font>：
```c
	int price = 0;
	
	printf("请输入金额：");
	scanf_s("%d",&price);
	
	int change = 100 - price;
	
	printf("找您%d元。\n",change);
```
<font size=2>* 代码块第三行的本应是 scanf 即止。
不过因为我用的是 Visual Studio，因其特性，我应把前文改成 scanf_s 才能生效。</font>

#### 代码解析

###### <b style="color: #5DD0C8;">1 - int price = 0 ;</b>
 <类型名称> <变量名称> = <初始值> 
这一行用 `int` 定义了一个**整数变量**，这个**变量名**为 price，初始值为 0 ：

- **变量**
	变量是一个保存数据（数字）的地方，我们还可让变量参与接下来的计算。在这个例子中，我们使用了 `100 - price`。 

- **标识符/变量名**
	”标识符“是”变量名“的术语。任何变量都需要一个名字，不同的标识符用于区分不同的变量。
		- 标识符也有它的构造规则：
		 标识符只能由<u>字母</u>、<u>数字</u>与<u>下划线</u>（ \_ ）构成，且不得用数字开头。
		 此外，C语言的关键字[^1]也不可以用作标识符。
<br/>

### 2.1.3 变量赋值与初始化，以及如何读输入的数字
<font size=2>（紧接上文）</font>

- **赋值运算符（=）**
	C语言中的 ”=“ 与数学中的 ”=“ 是<u>不一样</u>的。
		- 数学中的 ”=“ 是一个静态的”关系“。<u>表示 “=” 左右两边内容有着相等的值</u>。a=b 与 b=a 是一样的。
		- C语言中的 ”=“ 是一个动态的”行为“。是<u>将右边的值赋予左边的这么一个行为</u>。所以我们说 `price = 0` 就是在将 `0` 这个数值赋予 `price` 这个变量的行为。 a=b 与 b=a 表达的是不一样的东西，前者是把 b 的值赋予 a；后者是把 a 的值赋予 b。

- **初始化**
	C语言中的变量在第一次使用之前应该被赋予一次值（处于等号的左边），这就是对一个变量的初始化。不然，编译器可能自动为你设置初始值导致错误，也可能直接报错。

- **变量类型**
	`int` 代表这个变量的类型，是对这个变量的"定义"。


###### <b style="color: #5DD0C8;">1 - scanf_s("%d", &price) ;</b>
<scanf_s>（<格式化字符串>，&<标识符>）
与 `printf` **函数**不同，`scanf_s` **函数**是用于让用户输入并读取一个值。需要用 `%d` 来指定需要在终端输入并读取的变量 ：

- **函数**
	`printf` 与 `scanf_s` 之类的东西都被称为 “函数”：
		- 两者后方的 `f` 代表 “formatted”、格式化的。函数的功能依赖于双引号里面的字符串，格式字符串。在这个例子里，格式化字符串就是 `%d`。

- **关于括号内**
	在这个例子中，我们使用 `%d` 来指定那个需要在终端输入并读取的变量。重要的是**记得用逗号**隔开字符串与变量以及 **加上 `&` 符号**。
		- `&` 符号的作用目前还没有被介绍，不过一定得加上，不然没办法指定读取需要录入的变量。
<br/>

### 2.1.4 变量输入：如何让程序读入用户输入的数字
<font size=2>（紧接上文）</font>

- **关于 `scanf_s` 的输入规则**
	`scanf_s` 有自己的输入规则，我们需要去理解它才能更好地应用。这个规则不好单纯用语言描述，我们用例子来讲解：

```c
int a = 0;
int b = 0;

scanf_s("%d %d", &a, &b);
printf("%d %d\n", a, b);
```
```
1 2
1 2
```
- **正面例子：**
	我们在终端输入的格式与 `scanf_s` 后方字符串中的格式完全相符（<数值><空格><数值>），程序成功并完全的读取了我们输入的数值，程序也成功输出了同 `printf` 后方字符串格式一般的结果（<数值><空格><数值>）。

```c
int a = 0;
int b = 0;

scanf_s("%d, %d", &a, &b);
printf("%d %d\n", a, b);
```
```
1 2
1 0
```
- **反面例子** - 若 `scanf_s` 后的字符串变为 `"%d, %d"`:
	这一次，我们在终端输入的格式与 `scanf_s` 后方字符串中的格式不符了，因为我们没有用逗号隔开两组数值。这下，a 的数值被成功读取，改成1；但b 的数值没能被更改，停留在它的初始值，程序也就输出了 `1 0`。

```c
int a = 0;
int b = 0;

scanf_s("%d, %d ", &a, &b);
printf("%d %d\n", a, b);
```
```
1, 2



a
1 2
```
- **反面例子** - 若 `scanf_s` 后的字符串变为 `"%d, %d "`（第二个`%d`之后又多了个空格）:
	这一次，我们在终端输入的格式与 `scanf_s` 之后的格式符合，不过还是很难得出正确结果。我们在终端输入<1><,><空格><2><空格>后按下回车，并没有出现结果，而是换了一行，直到我们输入一个任意的健之后才跳出结果。
		- 这是因为在C语言里面**空格和换行都只起到“分隔”的作用，与其个数无关**。至于是打空格还是换行，打几个都无所谓，因为都**只算成一个分隔**。同时，直接**在结尾打空格或者回车不算分隔，只有在字符之间的空格、换行才算分隔**。所以必须要在打完空格或者换行以后再额外输入一个字符来创造格式要求的分隔。
		- 如果把 `scanf_s` 之后的字符串换成 `%d, %d\n` 的格式也是一样的结果，缘由解释在上一段落中。

```c
int a = 0;
int b = 0;

scanf_s("price%d, %d", &a, &b);
printf("%d %d",a,b);
```
```
1, 2
0 0
```
```
price1, 2
1 2
```
```
price 1, 2
1 2
```
- **最后一个反面例子** - 我们在字符串中很随意的加入了一串英文
	这一次，我们很随意的加入了一串英文，并在终端输入了 <1><,><空格><2>格式的字符。结果是没有任何一个数字被成功读入，跳出 0 0 的结果。直到我们几乎 100% 复制 `scanf_s` 后方字符串中格式的时候，两个数字才被成功读入。
	- 通过第三个例子我们发现，**在<一般字符串>与<格式化字符串>之间可能自带隔断性质**。我们可以在终端的 "price" 与 "数值" 之间加入空格甚至回车而不影响结果的成功。

**总之**
- 我们知道 `scanf_s` 是个很死板的函数，我们需要近乎 100% 完全复刻字符串内的格式作为输入形式才可以让程序成功读取。
- 之所以说 "近乎" 100%是因为我们刚刚知道了，只要在两个字符中的“分隔”性质字符会被无视数量的识别为一个分隔。
- 若格式化字符串以“分隔”性质的字符结尾时（`<空格>`或`\n`），我们需要在终端的以巴部分输入额外的字符来创造出分隔性质，以成功匹配让程序能够识别。
- `scanf_s` 后方字符串里的东西是它一定要我输入的东西，而不是让我看见的东西。所以我们可以在此之前写一串 `printf` 来提示需要输入的格式
<br/>

### 2.1.5 常量 vs 变量：不变的量是常量

```c
	int price = 0;
	
	printf("请输入金额：");
	scanf_s("%d",&price);
	
	int change = 100 - price;
	
	printf("找您%d元。\n",change);
```

###### <b style="color: #5DD0C8;">1 - 变量与常量的定义</b>
在 `int change = 100 - price` 一行中，我们看见 `change`、`price` 这两个可以随着用户输入而改变的量，我们称呼它为**变量**；同时也有 `100` 这个恒定不变的量，我们称呼它为**常量**，或者**直接量(literal)**。
	代码很重要的一点是让其他人也能轻易阅读。而相比于打出 "100" 这个没有任何附加解释的数字而言，用一个有解释意义的名字来定义它会更加适合。所以，我们最好<u>定义每一个数值</u>。

###### <b style="color: #5DD0C8;">2 - 一个更好的常量</b>

```C
const int AMOUNT = 100;
int price = 0;

printf("请输入金额：");
scanf_s("%d", &price);

int change = AMOUNT - price;

printf("找您%d元。", &change);
```

我们对之前的代码做了一些改变：

- **修饰符：`const`**
	`const`(constant) 会被写在 `int <变量名>` 的前方。它的目的是让一个变量在被初始化后就不能再被变更。
		即使我们之后油盐不进地试图二次修改这个变量的数值，程序也会报错来扼住我们的坏心眼子。

- **定义常量： `const int AMOUNT = 100;`**
	为了方便阅读，我们在代码的开头定义了一个常量。不过我们还注意到了一个小细节：**全大写的标识符**：
		这是一个约定俗成的规矩，当一个变量是常量时，我们最好把它的名字全部大写。

不过呢，因为不是每个客人都会支付 100 元票子的，所以我们最好让收银员自己定义 amount 变量。这样，我们需要去掉修饰符`const`。

###### <b style="color: #5DD0C8;">3 - 一个更合理的收银软件</b>

```c
int amount = 0;
int price = 0;

printf("请输入商品金额：");
scanf_s("%d", &price);

printf("请输入收款金额：");
scanf_s("%d", &amount);

int change = amount - price;

printf("找您%d元。",change);
```

我们把 amount 改成了一个变量。同时因为 amount 函数不再是常量了，所以我们把它改成了全小写。
<br/>

### 2.1.6 浮点数：整数运算的结果只有整数部分，不然就要用浮点数

该章节用于了解计算机中**函数与小数点的关系**，也就是 ”**浮点数**“ 及其相关知识。通过制作一个英尺英寸换算器的方式。
***

我们知道1英尺（foot）等于12英寸（inch），并且0.3048米等于1英尺。要求做一个英尺-米的换算器。
按照我们之前所学，我们可能编出以下代码：

```c
int foot = 0;
int inch = 0;

printf("您的身高是几英尺几英寸：");
scanf_s("%d %d", &foot, &inch);

printf("公制单位中，您的身高是%f米。\n", (inch/12 + foot) * 0.3048);
```
```
您的身高是几英尺几英寸：5 7
公制单位中，您的身高是1.524000米。
```
不不不不不对劲不对劲，我们找找问题出在哪里

```
您的身高是几英尺几英寸：5 8
公制单位中，您的身高是1.524000米。

您的身高是几英尺几英寸：5 11
公制单位中，您的身高是1.524000米。

您的身高是几英尺几英寸：6 3
公制单位中，您的身高是1.828800米。

您的身高是几英尺几英寸：6 9
公制单位中，您的身高是1.828800米。
```
看起来好像我们填写的英寸没起作用，貌似运算中只运用到了英尺呢。

这是因为在C语言中，**整数与整数运算，出来的结果只可能是整数**。
	如果本应该有小数，程序会**把小数直接删除，没有四舍五入**！

在上面的例子中，就算英寸为9，在除以12后依旧小于零，会被程序直接省略。
	`((11/12) 0.92 + 5) * 0.3048 == 5 * 0.3048 == 1.524` 


###### <b style="color: #5DD0C8;">1 - 初见浮点数，以及全新的关键字与格式化字符串</b>
我们将举例两种改法，并细细讲解新的知识与更改的原因
***

```c
double foot = 0;
double inch = 0;

printf("您的身高是几英尺几英寸：");
scanf_s("%lf %lf", &foot, &inch);

printf("您的身高是%f米。\n", (inch/12 + foot) * 0.3048);
```

上面是第一种编译方法。其中出现了很多新的符号与规则。

- **double**
	我们把变量前方的关键字从`int` 更改为了`double`。
		- 这是因为关键字 `int` 代表的是 “整型的”。也就是说这个关键字的用处是**将变量定义为整数**，这也让它只能进行整型的运算。
		- 关键字 `double` 代表着 “双精度浮点数”，程序在读取这个变量的时候自然就会让它进行非整型的运算。

- **%lf**
	这是在指代需要**输入**的 `double` 型变量时需要的格式化字符串。
	- 别忘了在需要指定的变量名前加上 `&` 来指定需要输入的变量。
	- %lf → %LF

- **%f**
	这是在指代需要**输出**的浮点数的时候需要的格式化字符串
	- 变量不一定得是`double`类型，也可以指代`int`变量。这在下个例子中有示范。


```c
int foot = 0;
int inch = 0;

printf("您的身高是几英尺几英寸：");
scanf_s("%d %d", &foot, &inch);

printf("您的身高是%f米。\n", (inch/12.0 + foot) * 0.3048);
```

这是第二种编译方法，我们做了两个改变。

- **%f**
	- 在上面的例1中有讲过，略。

- **将 `inch/12` 改为 `inch/12.0`**
	我们将一个“整数”（12）改为了一个“**浮点数**”（12.0）。

###### <b style="color: #5DD0C8;">2 - 浮点数的定义与相关运算规则</b>
<font size=2>（紧接上文）</font>

浮点数是计算机内部表达非整数的方式之一（包含分数和无理数）。

- **当程序在计算一个同时包含浮点数与整数的算式时，它会采用浮点数的算法而非整数的**。也就是说，它不再会省略小数了。我们就是用了这一特性才成功把程序掰直。
	- *明明最开始的算式 `(inch/12.0 + foot) * 0.3048)` 中也存在 `0.3048` 这个浮点数，为什么还是出错了？
		- 这是因为程序在计算算式时是**乘除先加减后再从左到右的规律**一步步计算的。规则如下：*
			(1 + 2 / 3) * 0.1  =<font size=2>（先运算除法，小数已被忽略）</font>
			=  (1 + <font color = red>0</font> ) * 0.1 =<font size=2>（发现浮点数，开启浮点数算法，但为时已晚）</font>
			= 0.1 
			= <font size=2>正确</font>
			(1.0 + 2 / 3) * 0.1 = <font size=2>（先运算除法，小数已被忽略）</font> 
			= (1 + <font color = red>0</font> ) * 0.1 =<font size=2>（发现浮点数，开启浮点数算法，但为时已晚）</font>
			= 0.1  
			= <font size=2>错误</font>
			(1 + 2 / 3.0) * 0.1 =<font size=2>（先运算除法，发现浮点数，开启浮点数算法，小数得到留存）</font> 
			=(1 + <font color = green>0.66667</font>) * 0.1
			=0.166667
			=<font size=2>正确</font>

---
[^1] C语言的关键字（也称保留字）为：Auto double int struct break else long switch case enum register typedef char extern return union const float short 等共三十二个单词。




