---
{"tags":["IC","UPC"],"dg-publish":true,"permalink":"/Instrucció al computador/宏观/","dgPassFrontmatter":true,"created":"2024-10-30T09:59:10.204+01:00","updated":"2024-11-18T14:42:18.181+01:00"}
---


### 1. 电路类型

- Circuito lógico combinacional (CLC) - 组合逻辑电路
	
	- 特点：
		- 没有记忆
		- 输入输出固定
		- 输出依赖于**当时的**输入，不依赖于之前的结果

- 禁忌：
	- 两条输出线路不能直接并成一条；
	- 入口与出口必须得有 0/1；
	- CLC 时，不可以有回路，但时序电路可以；

输入-输出的对照关系被称为 “función lógica"。
	 “w 依赖于 x 与 y 的关系” → “w = f(x, y)”


### 2. Cronograma

Cronograma 代表 “电路时间表”。
- 方波的起伏代表 “输入为1/输入为0”。
- 纵向排列以获得 “不同 入口/出口 在同时间下的对比”。

词汇：
- Glitch：期望之外的波动。

#####  <b style="color: #5DD0C8;">CLC</b>
- 当电路输入变化时：
	我们以电路中逻辑门的 “从左到右” 来 “从上到下” 地排列每个逻辑门的cronograma：
	
	- 思路如下：
		1. 这个变化影响到的第一个逻辑门是 !y，所以我们从它画起：
			1.1断定**该门的结果会因 y 的变化而变化**。
			1.2  察觉到 !y 的 Tp 是 10，我们**预留出一段时间**；
			1.3 在此之上，画出这个门中**信号的变化**（由 1（y 变化前的结果） 到 0（y 变化后的结果）；
			1.4 使用**箭头**标注出 Tp 与变化的瞬间。
		
		2. 接下来影响到的逻辑门是 x·!y 与 y·z，我们从前者开始：
			2.1 断定**该门的结果会因 y 的变化而变化**。
			2.2 察觉到 A1 的 Tp 是 10，我们在前者的预留上再**叠加 20 的预留**；
			2.3 画出这个门中信号的变化 （1 && 1 \== 1 （y 变前）→ 1 && 0 == 0（y 变后）)；
			2.4 使用**箭头**标注出 Tp 与变化的瞬间。
		
		3. 后者 y·z：
			3.1 断定该门的结果**不会**因 y 的变化而变化。
			3.2 预留出 20 u.t. （不经过 NOT）
			3.3 没有变化，一条直线
			3.4 没有变化，无需标注
		
		4. 总出口 w：
			4.1 断定该门的结果会因 y 的变化而变化；
			4.2 察觉 Tp，预留；
			4.3 画出信号的变化；
			4.4 箭头标注；
			**4.5 总结所有的 Tp。**
		
		5. 式子：T = Tp(NOT) + Tp(A1) + Tp(Or-2) = 10 + 20 + 20 = 50 u.t.
	
	![3 - 3.49.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%203/%E5%9B%BE%E7%89%87/3%20-%203.49.png)


## 3. 模块解析

#####  <b style="color: #5DD0C8;">一般模块</b>

- Decodificador（Dec）
	
	- 概念补充：Minterm
		如果一个 funcion logica 只有一种排列组合能导致其输出为1时，它就是一个 minterm（当 TV 的输出中只有一行为1，其余全0）。
			- 因为 And 门的特性，我们一般会使用它来组成 minterm。
				!a\*b\*c 是minterm，因为 000=0, 001=0, 010=0, 011=**1**, 100=0, 101=0, 110=0, 111=0。
	
	- Dec 的概念类似于一个哨卡，它只让一些特定的输入通过（输出1）。如果输入的不属于哪些特定输入，输出 0。
		- 通过拼凑不同的 And minterms 来设置 “可以通过的输入”。并在最后用 Or 门将不同的 minterms 集合起来。
		下图中，只当输入为 001、011、110、111 时，解码器的输出才为 1。设计思路就是将 minterm 001 + minterm 011 + minterm 110 + minterm 111。
	![Mx-2-1 + Decodificador.png](/img/user/ZZZZ%20%E5%9B%BE%E7%89%87%E4%BB%93%E5%BA%93/Mx-2-1%20+%20Decodificador.png)

- ROM
	

- Multiplexor (Mx-a-b)
	Multiplexor 是 “数据选择器”。用于在多个输入中选择其中一个作为输出。其中 a 代表输入的数量，b 代表输出的数量。
	
	- 最小单位 - Mx-2-1
		**结构**：Mx 的最小单位有两个输入口 (x)，一个选择输入口 (s) 与 一个出口 (w)。
		**原理**：如果 s 口为 0，输出 x0 的值；如果 s 口为 1，输出 x1 的值。
		- **图例**：
			![4 - 4.8.02.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.8.02.png)
	
	- 堆叠单位 - Mx-a-b
		
		**结构**：可以分为 x 入口，s 入口 与 w 出口三部分来理解。
			- x 入口就是输入的可选项。整个 Mx 以它们为基础建立。
			- s（select）入口
				**用处**：用于选择 “需要输出哪个 x 入口的值“。一般来说，s 入口对应的 ”十进制值“ 对应输出 x 口的编号。
					比如：假如 s2=0, s1=1, s0=1，三者凑起来=011=3；一般来说这种组合对应着 ”输出 x3 口“。
				**结构**：s 口的数量与 x 口的数量存在对照关系。公式为 **s^m = x** 。需要 m 个 s 口有能力对应到全部的 x 。
			- w 口 代表输出，就是 s 口对应的 x 口的值。
		
		**堆叠方式**：以 Mx-8-1 为例。
			还记得我们说过 s 口与 x 口的对照关系是 s^m=x，我们通过这个公式来制作电路。
			1. 这个例子中，我们需要三个 s 口：s^0, s^1, s^2。其中，2^0=1, 2^1=2, 2^2=4。
			2. 然后看图吧，每个 2 的幂次都对应一个层级：
				![4 - 4.8.22.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.8.22.png)

#####  <b style="color: #5DD0C8;">正整数运算模块</b>
对于 números naturales / Unsigned integers / 正整数:

- ADD / sumador 相关
	
	- Half-Adder (Ha)
		**结构**：Half-Adder 有两个入口+两个出口。由一个 And-2 与一个 Xor-2 组成。
		**用处**：用于将两个等价的输入相加：
			- 输入 00，输出 00（0）。
			- 输入 10 / 01，输出 01（1）。
			- 输入 11，输出 10（2）。
		- **图例**：
			![4 - 4.7.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.7.png)
	
	- Full-adder (Fa)
		**结构**：Fa 有三个入口与两个出口。由三个 Ha 组成 / 由两个 Ha + 一个 Or-2 组成。
		**特性**：Fa 的两个**出口的名字是固定的**，分别是 c（carry）与 s（sum）。
		**用处**：用于将三个等价的输入相加：
		- **图例**：
			![4 - 4.8.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.8.png)
	
	- ADD
		**结构**：由两根输入总线 / buses，一根输出总线与一根输出 carry 组成。
		**原理**：
			- 堆叠 n 个 Fa 以计算 n 位数。
			- 使用 Fa 将同位的两个值相加。如果需要进位，向左边一位加一。
		**不可表达**：当第 n-1 位也需要进位。
		- **图例**：
			![4 - 4.3.2.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.3.2.png)

- SUB / restador 相关
	
	- Full-substractor (Fs)
		**结构**：Fs 也有三个出口与两个出口。内部不明。
		**特性**：Fa 出口与入口的排序和名字都是固定的。
			- 入口：从左到右 xyz 。其中 x 固定为加数，y 为减数，z 为欠位。
			- 出口：b（borrow / 欠位）；s（subtract / 差）。
		- **图例与 TV**：
			![4 - 4.3.21.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.3.21.png)
	
	- SUB
		**结构**：也是有两根输入总线，一根输出总线与一根输出 borrow 组成。
		**原理**：
			- 堆叠 n 个 Fs 以计算 n 位数。
			- 使用 Fs 将同位的 x - y 。如果需要借位，向左边一位减一。
		**不可表达**：当结果是负数。
		- **图例**：
			![4 - 4.3.22.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.3.22.png)

- SL-k 相关
	
	- Shift Left - k（SL-k）
		**结构**：可以分为三部分理解。
			- 输入的最左边 k 位：我们在这里装一个 Or 门以检测是否有 1。若有，无法表达
			- 输出的最右边 k 位：固定为 0。
			- 输入输出的中间几位：简单的向左移位。
		**原理**：如果目的是将某位数乘以 2 的 k 次幂，相应乘法器的目的就是向左平移 k 位，并在最后 k 位填充 0 。
		**不可表达**：当输入的前 k 位有 1 时，不可表达。
		- **图例**：
			![4 - 4.4.31.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.4.31.png)

- SRL-k 相关
	
	- Shift Right Logically - k (SRL-k)
		**结构**：也可以分三部分理解，甚至比 SL-k 更简单。
			- 输入的最右边 k 位：无用。
			- 输出的最左边 k 位：固定为 0。
			- 输入输出的中间几位：简单的向右移位。
		**原理**：如果目的是将某位数除以 2 的 k 次幂，相应除法器的目的就是向右平移 k 位。并将右边的多余位数直接抹除。
		**不可表达**：无。
		- 图例：
			![4 - 4.5.31.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.5.31.png)

- Comparador 
	共有三种 comparadores：EQ（是否相等），LTU（是否小于）与 LEU（是否小于等于）。其中两个都需要用到 z 模块。
	
	- z
		**结构**：由一堆 And 模块堆叠而成。
		**用处**：检查输入是否全都是0。如果全都是 0，输出 1；若中间参杂一些 1，输出 0 。
	
	- EQ
		**结构**：由 SUB 与 z 组成。
		**原理**：将两个入口通过 SUB 相减，并通过 z 模块观察答案是否全部等于 0。
			- 若等于 0，相同，输出 1；
			- 若不是全是 0，不同，输出 0。
		- **图例**：
			![4 - 4.6.01.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.6.01.png)
	
	- LTU
		**结构**：仅由 SUB 构成。
		**原理**：将两个入口通过 SUB 相减，并观察 borrow 口是否等于 1。
			- 若 b=1，x 小于 y。
			- 若 b=0，x 不小于 y。
	
	- LEU
		**结构**：由 SUB、z 与 Or 门组成。将 SUB 的 b 口 与 z 口用 And-2 相连。
		**原理**：只要满足二口其一，输出=1。
		- **图例**：
			![4 - 4.6.02.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.6.02.png)


#####  <b style="color: #5DD0C8;">整数运算模块</b>
对于 enteros / signed integers / 整数

如今的计算机一般用 “Complemento a dos - Ca2” 的语法来计算整数。特点有三：
1. 它的 rango 比较平均，但是负数一定比正数多一位。
2. 与正整数运算不一样：整数运算的首位不是数字意义，而是符号意义的。
	例：正整数中，110=6；整数中，110=-2 。
	- 一个数字首位为 1 时，它是负数；
	- 首位为 0 时，它是负数。

- Ca2 中的二进制 → 十进制
	- 如果想要将 0 开头的二进制数转换成十进制，需要将每一位的值乘以它的 2^(位数)。
		例：01101 = (0 * 2^4) + (1 * 2^3 ) + ……
	- 如果想要将 1 开头的二进制数（Ca2 负数）转成十进制，也要将每一位的值乘以它的 2^(位数）。不过，**符号位需要取负！！！**
		例：11101 = **-(1 * 2^4)** + (1 * 2^3) + (1 * 2^2) + (0 * 2^1) + (1 * 2^0) = -16+8+4+1 = 3。

- Extension de rango (SE)
	如果想要拓展一个整数的位数并保持它的值不变，需要复制它的首位。
		例：将三位的 101 拓展成六位：111101；将三位的 011 拓展成六位：000011。
	用电路模块来表达的话，如下：
	- **图例**：
		![5 - 5.3.31.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%205/%E5%9B%BE%E7%89%87/5%20-%205.3.31.png)

- ADD
	
	结构与正整数的模块一致，但结果存在变化：
	- 两个正数相加时
		如果两个整数的 **n-2 位相加时需要进位**，则 n-1 位会等于 1。可是 Ca-2 中 n-1 位等于 1 是负数的标志。所以这时，**答案不可表达**。
	- 一正一负相加时
		全都可以表达。
	- 两个负数相加时
		如果两个负数的 **n-2 位相减时需要借位**，则 n-1 位会等于 0。可以 Ca-2 中 n-1 位等于 1 时正数的标志。所以这时，**答案不可表达**。
	- **总结：同性相加时，如果结果的性质与加数一致，正确；如果性质相反，错误。**
	
	- 我们会使用变量 vn、cn 与 cn-1来检测是否存在 overflow / 溢出：
		- cn 代表两个加数首位的 carry。
		- cn-1 代表两个加数 n-2 位的 carry。
		- vn 代表 cn 与 cn-1 的 Xor 结果。如果 vn=1，代表溢出；若 vn=0，代表正常。
		- **图例**：
			![[5 - 5.4.11no.png\|5 - 5.4.11no.png]]

- Negador / Cambio de signo
	**结构**：在 ADD 的基础上，将：
		- 输入取反
		- Fa 换成 Ha
		- 将最开始一位的进位变成 1。
	**原理**：因为 Ca-2 中正数与负数的 Rango 差距，所以需要额外 +1。
	**不可表达**：也是因为 Ca-2 中负数的 Rango 要比正数的 Rango 宽，所以当**输入 = 最小域的极致**时，无法表达。
	- **图例**：
		![5 - 5.5.31.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%205/%E5%9B%BE%E7%89%87/5%20-%205.5.31.png)

- SUB
	





#####  <b style="color: #5DD0C8;">正整数 + 整数运算模块</b>
下图的 ADD 模块可以同时作用于 naturales 与 enteros。

- **cn 口只在 naturales 的情况下有意义**。若其 =1，代表 ”无法表达“。
- **vn 口只在 enteros 的情况下有意义**。若其 =1，代表 ”无法表达“。

- **图例**：
	![5 - 5.4.21.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%205/%E5%9B%BE%E7%89%87/5%20-%205.4.21.png)

#####  <b style="color: #5DD0C8;">逻辑门</b>

- 逻辑门模块
	除了小单位的逻辑门之外，逻辑门还可以连接总线，当作模块使用。
	**结构**：n bits 的逻辑门模块由 n 个相应的逻辑门堆叠组成。
	**原理**：将输入的**同位**作逻辑门应用。
	- **图例及实例演示**：And 模块实例 与 各个逻辑门模块输入输出演示
		![4 - 4.7.11.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.7.11.png)
		![4 - 4.7.22.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%204/%E5%9B%BE%E7%89%87/4%20-%204.7.22.png)

- Not
	w = !x
- And
	w = x\*y
	特性：Conmutativa/交换律（x\*y = y\*x）与 Asociativa/结合律 ( (xy)z = x(yz)。
- Or
	w = x+y
	特性：交换律与结合律
- Xor
	当输入不同时，输出为 1（00 或 11 时输出为 0）。
	由两个 Not，两个 And-2，一个 Or-2 组成。

逻辑门堆叠时，树状结构堆叠或许比线性堆叠更好。
Elemento neutro 可用来消耗一个逻辑门入口。And 门的 elem. neutro 是 1；Or 门的是 0。


## 4. 公式结构

**Sistema de numeración binario**
在计算机中，**自然数** 被以 **二进制** 的方式表达。

![5 - EQ1.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%205/%E5%9B%BE%E7%89%87/5%20-%20EQ1.png)

![5 - EQ2.png](/img/user/Instrucci%C3%B3%20al%20computador/Tema%205/%E5%9B%BE%E7%89%87/5%20-%20EQ2.png)

其中，脚缀的意义如下：

- **n-1 ... 0**
	代表 bit 所在的那一位的编号。一个四位数的最大 n 是 3，因为最小的编号是 0。
- **i** 
	代表 {n-1 n-2 ... 1 0} 的集合。EQ1 中意为所有的 bits 要么是0要么是1。
- **u**
	代表该数是，一个以**自然数**（unsigned integer) 方式表达的二进制向量。
	计算方式是 “X_i * (2^编号)” ——或者—— (那一位的值) \* (2^(编号))。

- Xs 代表对 **s**igned integers / 整数 的表达。
- Xu 代表对 **u**nsigned integers / 正整数 的表达。

**Rango**
自然数的 rango 代表包含它所有可能的值的范围。
一个 “能被使用二进制表达的**自然数**” 的范围如下：

