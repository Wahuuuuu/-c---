---
{"tags":["翁恺","表达式","取余","运算符","调试","套路","赋值运算符","单目运算符","复合赋值","递增","递减","测验"],"dg-publish":true,"permalink":"/翁恺计算机入门/2.2 第二周第二讲/","dgPassFrontmatter":true,"created":"2024-04-27T00:28:54.407+02:00","updated":"2024-07-18T00:22:31.497+02:00"}
---

### 2.2.1 表达式：运算符和算子、取余计算、程序就是数据加计算

###### <b style="color: #5DD0C8;">1 - 表达式的定义</b>
一个表达式是一系列**运算符**和**算子**的组合，用于计算一个值：

`HourDifference = (TotalMinute1 - TotalMinute2) / 60;`
- 这就是一个表达式的例子。我们把一个表达式中的变量与数字统称为“**算子**”（如 `HourDifference` 与 `60`），并将表达式中的符号统称为“**运算符**”（如 `+`、`=` 等等）。

###### <b style="color: #5DD0C8;">2 - 初见”取余“</b>
我们通过编译一个时间差计算器来了解”取余“的应用。

我们之前了解到，在进行整数运算的时候，答案只能是整数。如若答案中本应有小数（余数），会被直接忽略。不过，我们可以用取余来拿回被忽略的余数。例：
	除法运算：
		5 / 2 =(2 ......1)= 2
	取余运算：
		5 % 2 =(2 ......1)= 1

###### <b style="color: #5DD0C8;">3 - 时间差计算器：取余的应用</b>
现在我们来编译一个时间差计算器。

在每次编译前，必不可少的思考环节就是 “我们需要的是什么数据呢？”。之后，我们根据需要数据类型的来命名并定义一些变量，再通过 `scanf_s` 来读取这些变量。
	这个例子中，每个时间都有 “小时” 与 “分钟” 的单位，所以每个时间需要两个变量；同时，因为需要两个时间才能计算时间差，所以我们一共需要读取两个时间，一共四个变量。

之后，就来到了 "该如何运算呢？" 的环节。

计算时间差有它的特殊性，如果我们只是简单的小时位减去小时位、分钟位减去分钟位的话，我们在计算3:20 与 5:10 的差距时，就会得出 2个小时 与 -10分钟 的结果。
	这不优雅（摇晃酒杯）
	我们最好把时间的单位统一为分钟，再进行后续计算。

```c
int Hour1, Minute1;
int Hour2, Minute2;

printf("请输入第一个时间：");
scanf_s("%d %d", &Hour1, &Minute1);

printf("请输入第二个时间：");
scanf_s("%d %d", &Hour2, &Minute2);

int TotalMinute1 = Hour1 * 60 + Minute1;
int TotalMinute2 = Hour2 * 60 + Minute2;

int HourDifference = (TotalMinute1 - TotalMinute2) / 60;
int MinuteDifference = (TotalMinute1 - TotalMinute2) % 60;

printf("两个时间的时差为%d时%d分。", hourDifference, minuteDifference);
```
<font size=2>这是我自己写的，老师写的在文章末尾</font>[^1]
<br/>

## 2.2.2 运算符优先级：优先级、结合关系、赋值运算符

###### <b style="color: #5DD0C8;">1 - 表格：运算符的优先级排序</b>
这个单元的主题围绕着一张表格。这张表记载了C语言中运算符默认的先后计算顺序：

|                优先级                |                运算符                |                  运算                  |                 结合关系                 |                  举例                  |
| :-------------------------------: | :-------------------------------: | :----------------------------------: | :----------------------------------: | :----------------------------------: |
| <div style="width:120px;">1</div> | <div style="width:120px;">+</div> | <div style="width:120px;">单目不变</div> | <div style="width:120px;">自右向左</div> | <div style="width:120px;">a*+b</div> |
|                 1                 |                 -                 |                 单目取负                 |                 自右向左                 |                 a*-b                 |
|                 2                 |                \*                 |                  乘                   |                 自左向右                 |                 a\*b                 |
|                 2                 |                 /                 |                  除                   |                 自左向右                 |                 a/b                  |
|                 2                 |                 %                 |                  取余                  |                 自左向右                 |                 a%b                  |
|                 3                 |                 +                 |                  加                   |                 自左向右                 |                 a+b                  |
|                 3                 |                 -                 |                  减                   |                 自左向右                 |                 a-b                  |
|                 4                 |                 =                 |                  赋值                  |                 自右向左                 |                 a=b                  |

 在 [[翁恺计算机入门/3.2 第三周第二讲\|3.2 第三周第二讲]] 中有该表格的升级版 

这张表中大致有两个特别值得讲解的点：第一优先级的**单目运算符**与最低优先级的**赋值运算符**：

###### <b style="color: #5DD0C8;">2 - 单目运算符</b>
“单目”意味着它仅仅只会影响到**一个**算子，也就是粘着运算符的那个。

这些运算符会改变和它粘着的算子的性质。如果是 `+` 运算符则保持算子的正负不变；如果是 `-` 运算符则会改变算子的正负（正数会变为负数，负数会变为正数）。

在之后我们还会看到 “递增递减运算符”。

###### <b style="color: #5DD0C8;">3 - 赋值运算符</b>
在c语言中，`=` 是一个运算符。即使是一个只有 `=` 的算式，也是有结果的。
	举个例子：`a = 6` 这个算式是有结果的。它的结果就是 `a` 被赋予的值，也就是 `6`。
	同时，因为赋值号是自右向左运算的，所以在计算一个类似于 `a = b = 6` 的算式时，程序会先去思考 `b = 6` 是什么，再计算 `a = (b=6)`。
		- `a = b = 6`  →  `a = (b=6)`  →  `a = 6`

**嵌入式赋值**

```c
int a = 6;
int b;
int c = 1 + (b = a);
```

上方的第三行代码中使用了 “嵌入式赋值” 的赋值方法。他的本意是想要用一行代码做两件事：
1. 定义 `c`变量
2. 将 `a`变量赋值给 `b`变量

不过这是一个反面例子，首先，这种赋值方式不利于阅读；其次，这种赋值方法很容易产生错误。正确例子如下：

```c
int a = 6;
int b = a;
int c = 1 + b;
```

这样写代码你好我好大家好。
<br/>

## 2.2.3 交换变量：如何交换两个变量的值、调试功能与套路

###### <b style="color: #5DD0C8;">1 - 交换两个变量的值的方法</b>

```
int a = 5;
int b = 6;
```

我们可以看到两个变量以及目前它们的值：
`a`变量的值是`5`，`b`变量的值是`6`。现在我们想让 `a`变量的值变为`b`变量的值且`b`变量的值变成`a`变量的值。

这个时候可能就会有大聪明打出这样一行代码：

```c
a = b;
b = a;
```

这行代码是**错误**的。错在了忽略了代码的**顺序性**上。
	 我们编译的代码通常是按照**从上到下，从左到右**的规律一步一步进行的。这样的话编译器运行的结果就会如下：
		 ``a = b ;`` <font size=2>（a 的值变为 6。b的值不变。）</font> 
		 `b = a ;` <font size=2>（b的值变为a的值，也就是6，实际上并没有任何变化。a的值不变。）</font>
			- <u>结果：a = 6, b = 6，失败</u>。

**正确**的方法是使用第三个变量来帮助我们进行这个过程：

```c
int a = 5;
int b = 6;
int c = 0;

c = a;
a = b;
b = c;

printf("a = %d, b = %d \n", a, b);
```

```
a = 6, b = 5

```

成功运行，原理就好像是调换一杯可乐与一杯雪碧。肯定需要第三个杯子（或者含在嘴里）以成功调换两杯饮料。


###### <b style="color: #5DD0C8;">2 - 如何进行调试</b>

- **设置断点**
	在进行调试之前，我们需要设置一个**断点**以决定程序暂停的位置。只需**左键一行代码所属数字更左方的空白**即可，若点击处出现一个红点即代表设置成功。
	
	我们就像在带有断点的那行设置了一排路障，拦住了程序前进的路线。**程序的运行会在断点前一行停止（不包括断点行）**。

- **开始调试**
	设置断点后即可开始调试。VS2022 中的调试功能位于软件顶端的任务栏中。或者按 F5 快捷键也可以直接开始调试。
	
	点击调试后，我们发现断点的位置出现了一个**箭头**，这代表这一行是**尚未运行且即将运行的**。
		- 我设置的断点位于`c = a;`一行中。所以调试窗口中显示的变量的值都还是最初的样子
	
	接下来，我们可以按 F11（逐步执行的快捷键）以让程序进行到下一句
		- 我们看见**箭头**下移到了接下来的一句，且调试窗口也有所变化，变量 `c` 的数字变成了 `5`。数字 `5` 还被用红色高亮以让这个经历的改变更加明显。
	
	最后，一步一步按 F11 检查代码直到成功运行。


###### <b style="color: #5DD0C8;">3 - 编程中的”套路“</b>
所谓套路就是一串流程，利用不同的知识点以达成一个目的；也可以说是一般人用于解决这个目的的程序。
	刚才接触的 ”交换“ 代码就是一个套路。人们通常会使用第三个代码以达成交换两个代码的值的目的。

”套路“ 需要通过阅读别人的代码来积累。知道别人用什么方法来达成这个目的，学过来，再在自己需要的时候掏出来。
<br/>

## 2.2.4 复合赋值和递增递减

###### <b style="color: #5DD0C8;">1 - 复合赋值</b>
在 C 语言中，五个运算符（+、-、\*、\/、、%）都可以与赋值运算符结合起来，形成一个 “**复合赋值运算符**”（=+、=-、=\*、=\/、=\%）。

**很重要的一点**：在一般运算符与赋值运算符之间<font color = red>不能有空格</font>，不然就不是这个意思了！！

在`int a = 10;`的前提下，它们的意义如下：

- 加、减复合赋值运算符：
```c
a += a *2 +2
a = a + (a *2 +2)
a = 10 + (10 *2 +2)
a = 10 + 22
a = 32
```

- 乘、除、取余赋值运算符：
```c
a *= a *2 +2
a = a * (a *2 +2)
a = 10 * (10 *2 +2)
a = 10 * (22)
a = 220
```

###### <b style="color: #5DD0C8;">2 - 递增递减</b>
除了上面的复合赋值运算符之外，还存在一对很有意思的运算符，它们就是 **递增递减运算符**（++、--）。

这一对是一种单目运算符，它们可以改变那个和它们紧连着的算子的值。<u>它们用于给那个算子 +1 或者 -1</u> 。

下面的算式都是等值的：
```
++a
a += 1
a = a + 1
a = 10 + 1
a = 11
```

复合赋值运算符既可以被放在变量的前面也可以被放在变量的后面。它们<u>各自有不同的意义</u>。放在变量前面的时候被称为 “前缀形态” （++a）；放在变量后面的时候被称为 “后缀形态”（a++）。
	特殊的是，这一对单目运算符<font color = red>只能作用于 “变量” 类型的算子</red>，它们无法作用于数字类型的算子。也就是说，它们只能以 `++a` / `a++` 的形式出现，`++5` / `5++` 这种表达式是没有意义的。

我们说过，`a++` 和 `++a` 都有各自不同的意义。这个需要从 “表达式本身的结果” 与 “表达式带来的副作用“ 来理解（至少翁恺老师是这么形容的）：

- **前缀形态的意义**：
	前缀形态（`++a`）本身的结果是 `a` 本身的值，是 +1 之前的值。示范如下：

```c
printf("第一次a = %d\n", a);
printf("第一次++a = %d\n", ++a);
printf("第二次a = %d\n", a);
printf("第二次++a = %d\n", ++a);
printf("第三次a = %d\n", a);
```

```
第一次a = 10
第一次++a = 11
第二次a = 11
第二次++a = 12
第三次a = 12
```

我们可以很清晰的看到 `++a` <u>本身的结果是 +1 之后 的值</u>，并且运行完 `++a` 之后，`a` 的值会得到 +1（副作用）。

- **后缀形态的意义**：
	前缀形态（`a++`）本身的结果是 `a` +1 之后的值，而并非本身的值。示范如下：

```c
printf("第一次a = %d\n", a);
printf("第一次a++ = %d\n", a++);
printf("第二次a = %d\n", a);
printf("第二次a++ = %d\n", a++);
printf("第三次a = %d\n", a);
```

```
第一次a = 10
第一次a++ = 10
第二次a = 11
第二次a++ = 11
第三次a = 12
```

我们可以很清晰的看到 `a++` <u>本身的结果是尚未 +1 的值</u>，但是在运行完 `++a` 之后，`a` 的值同样会得到 +1（副作用）。

或许并不需要理解递增递减单目运算符，把它当作一个定义一样背下来可能也是不错的选择。

还有一点很重要的事，请让递增递减运算符止步于单独使用，千万不要把它们套进表达式中组合使用。不然：

```c
a = b +=c++-d+--e/-f 
```

解题思路：

1. 我们确认，每两个变量之间必定有一个运算符，且第一步把单位划分成算子/运算符会便利于运算。所以，我们把表达式细分成：
	`a = b += c++ - d + --e / -f`

2. 根据运算法则，我们应优先计算单目运算符。至此，表达式变成这样：
	`a = b += c - d + (e - 1) / -f
	- `c++` - `c`，因为后缀形态本身的结果是尚未 +1 的。
	- `--e` - `(e - 1)`，因为前缀形态本身的结果是 -1 后的。

3. 根据运算法则，我们应优先计算乘、除、取余。表达式不变。

4. 根据运算法则，我们应接着计算加、减。表达式不变。

5. 根据运算法则，我们最后应预算赋值号，按照从右到左的顺序。所以，我们应优先计算复合赋值号，表达式变为：
	`a = b = b + [ c - d + (e - 1) / -f ]`

6. 最后，得出结论：
	`b = b + [ c - d + (e - 1) / -f ]`
	`a = b`


会让人头秃 


## 测验：倒序

题目内容： 逆序的三位数：

程序每次读入一个正三位数，然后输出逆序的数字。注意，当输入的数字含有结尾的0时，输出不应带有前导的0。例如输入700，输出应该是7。

提示：用%10可以得到个位数，用/100可以得到百位数.... 将这样得到的三个数字合起来：百位_100+十位_10+个位，就得到了结果。

注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求输出逆序的数字，程序就只能输出这个数字，除此之外的任何内容都不能输出。

输入格式： 每个测试是一个3位的正整数。

输出格式： 输出逆序的数字。

输入样例： 123

```c
	int Read_Number = 0;
	
	scanf_s("%d", &Read_Number);
	
	int HundredDigit = 0;
	int TensDigit = 0;
	int SingleDigit = 0;
	
	HundredDigit = Read_Number / 100 ;
	TensDigit = (Read_Number - (HundredDigit * 100)) / 10 * 10 ;
	SingleDigit = (Read_Number - (HundredDigit * 100) - TensDigit) * 100;
	//	如果要运用取余的话将上行改成 SingleDigit = Read_Number % 10 *100;

	
	int Out_Number = HundredDigit + TensDigit + SingleDigit;
	
	printf("%d", Out_Number);
```
- 个人解答
	可以将三位数中的每一位都分别出来，然后在最后相加。剩下的就交给数学。
	不过老师好像希望我运用取余。

- 老师纠错
	我的版本有两个问题：
	1. 十位数计算部分过于冗长（好吧个位数也是）。
		老师的办法是对输入的数字 %100 得到 后两位，再 /10。两步即可完成。
	
	2. 思路过于模糊。
		我在二次赋值 `HungredDigit` 的时候得出的结论并不是如字面所说的一位数，我为图省事直接加上零了。实际上我可以在最后输出的时候再加零，这样可能会清晰一些。下方是老师版本的代码：

```c
	int Read_Number = 0;
	
	scanf_s("%d", &Read_Number);
	
	int HundredDigit = 0;
	int TensDigit = 0;
	int SingleDigit = 0;
	
	HundredDigit = Read_Number / 100;
	TensDigit = Read_Number % 100 / 10;
	SingleDigit = Read_Number % 10;
	
	int Out_Number = HundredDigit + TensDigit * 10 + SingleDigit * 100;
	
	printf("%d", Out_Number);
```

属实简洁 ( ･∀･)b



---
[^1] 
```c
int hour1, minute1
int hour2, minute2

scanf_s("%d %d", &hour1, &minute1);
scanf_s("%d %d", &hour2, &minute2);

int t1 = Hour1 * 60 + Minute1;
int t2 = Hour2 * 60 + Minute2;

int t = t2 - t1;

printf("两个时间的时差为%d时%d分。", t/60, t%60);
```







