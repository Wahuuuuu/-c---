---
{"tags":["翁恺"],"dg-publish":true,"permalink":"/翁恺计算机入门/5.1 第五周第一讲/","dgPassFrontmatter":true,"created":"2024-07-17T20:09:31.897+02:00","updated":"2024-07-17T23:54:19.349+02:00"}
---

### 5.1.1 for 循环：这是最古老的循环，确实样子看上去有点古怪

让我们通过制作一个**阶乘计算器**来初次认识认识 `for` 语句吧
#####  <b style="color: #5DD0C8;">1 - 阶乘</b>
首先的首先，先让我们来认识**什么是阶乘**。

- 在 c 语言中，阶乘的结构是 **n!** 。
	**n** 是个代号，代表任意一个**数字**；
	**!**  是阶乘的**运算符**。

阶乘的计算方法就是 1 * 2 * 3 * 4 * ... * n ，从 1 开始乘，一直到 n（任意数字）为止：
- 3!  =  1 * 2 * 3  =  6
- 8!  =  1 * 2 * 3 * 4 * ... * 8  =  40320
- 1!  =  1
- 0!  =  0

#####  <b style="color: #5DD0C8;">2 - 测试版阶乘计算器</b>
好了，这样看来的话，阶乘不也就是一个循环而已嘛。我们结合上之前的知识，三下五除二就可以敲出：

```c
int n = 0;

scanf_s("%d", &n);

int i = 1;
int Factor = 1;
while (i <= n) {
	Factor *= i;
	i++;
}
```

很完美，不过 c 语言有另外一种语句类型，可以更简短的表达同样的类型。它就是`for`语句。

#####  <b style="color: #5DD0C8;">3 - 初识 for 语句</b>
使用`for`语句不带任何润色的，直接呈现上方`while`部分的代码的话，会是这样：

```c
int Factor = 1;
int i = 1;
for (i = 1; i <= n; i++) {
	Factor *= i;
}
```

###### <b style="color: #5DD0C8;">3.1 - 基础结构</b> 
```c
for (<初始动作>; <条件>; <循环后做事>) {
	<循环体>;
}
```

我们看到，`for`语句与`while`语句在结构上很相似，但也有不同。它的圆括号中被分割出了**三个区域，用于填上三个表达式**：

- 第一个表达式：代表这个语句的**初始动作**；
	仅在第一次进入`for`语句时运行，但必定运行一次，无论条件是否成立）。

- 第二个表达式：代表进行循环的**条件**
	同`while`的用法。

- 第三个表达式：代表在每一轮之后，会做的事情，无论条件是否成立；
	在第一轮循环结束后才运行。

最后，`for`语句也和`while`语句一样，有一个所属于它的**循环体**。

###### <b style="color: #5DD0C8;">3.2 - 语句逻辑</b> 

```c
int Factor = 1;
int i = 1;
for (i = 1; i <= n; i++) {
	Factor *= i;
}
```

该语句逻辑如下（设`n`为 2）：

1. 执行初始动作（将 1 赋值给 `i`）；
2. 第一次判断条件，条件成立；
3. 执行循环体
4. 执行最右边的表达式（递增`i`）；
5. 第二次判断条件，条件成立；
6. 执行循环体；
7. 执行最右边的表达式（递增`i`）；
8. 第三次判断条件，条件不成立，跳出循环。

###### <b style="color: #5DD0C8;">3.3 - 概括与翻译</b> 
整体概括下来，感觉`for`语句就像一个带计数功能的循环。我们可以为这个循环专门建立一个变量，并给它赋上一个值，等同于需要它需要循环的次数。之后我们再初始化一个变量，让它一定调整，等到这个值等于前面那个，循环停止。

如果要更浅显地理解这个语句，我们可以把`for`语句翻译成 “**对于**”：**对于**（一开始的`i = 1`），**当**（`i <= n`）**时，执行循环体。最后，执行**（`i++`）**，并再次检测条件是否成立**。

#####  <b style="color: #5DD0C8;">4 - 套路：在求积的时候就不能把变量初始化成 0 了哦</b>
不知道你有没有注意到，在之前的代码中，我们把`Factor`和`i`初始化成了 1，而不是 0。这是因为它们是被用来进行乘法的，如果初始化成 0 的话，这个代码就会沉入 0 号空洞，永不见天日，这辈子都找不到它的 1，和更大的数字了（0 * 10086  =  0）。

#####  <b style="color: #5DD0C8;">5 - 阶乘计算器的优化</b>
好啦，在了解清楚更高级更优雅的解题方法之后，现在是优化时间！
###### <b style="color: #5DD0C8;">5.1 - 将变量初始化塞进 for 语句中</b> 
```c
int Factor = 1;
for (int i = 1; i <= n; i++) {
	Factor *= i;
}
```

程序其实可以被缩短成这样。我们把定义`i`变量的语句塞进了`for`语句的第一个表达式中，我们选择这么做是因为两点：

1. `i`变量在`for`语句外是用不到的：
	`i`在这个程序中只起到阶乘的递增作用，所以我们即使这么做也不会让整个程序难以理解。一样的道理，我们不能对在`for`语句外也有用的`Factor`做这事。

2. Visual Studio 2022 支持这种编译方式：
	这种编译方式是 C99 专有的，不过即使是一些支持 C99 的编译软件也不支持这种编译方式（但 Visual Studio 2022 恰好就支持这种编译方式）。

###### <b style="color: #5DD0C8;">5.2 - 将 i 赋值为 2，节省一轮循环</b> 
```c
int Factor = 1;
int i = 1;
for (i = 2; i <= n; i++) {
	Factor *= i;
}
```

在这之前，我们知道在求积的过程中，1 * 1可以说是没太多意义的。1 * 1 * 2 与 1 * 2 的结果完全相等，但在这个程序中，前者却比后者**多一轮循环**，但是勤（kou）俭（kou）持（sou）家（sou）、以性能为天的程序员们对此完全接受无能！！！

为此，我们把`for`语句的初始动作改为了`i=2`，一眼看上去好多了。不过在这背后，还有个**隐藏的危险：**`n`=1。

当`n`=1 时，`i`被初始动作赋值成 2 。此时的`i`要大于`n`，循环条件将会**不成立**，`Factor`将会以它的初始值被输出！！

但在这个例子下，`n`=1 情况的标准答案刚好就是 1，也就是`Factor`的初始值，所以我们还真可以这么操作，以剩下一个循环的性能。

不过，在接下来的章节，我们将会推敲出一个最完美的阶乘计算器。它也可以帮我们省掉 1 * 1 的那一次循环，且没有任何运气成分。

#####  <b style="color: #5DD0C8;">6 - 宇宙无敌暴龙EX · 完美 · 阶乘计算器</b>
总感觉这个程序还能继续优化……这个时候，我们可以试着**换位**思考一下。

在一起倒立三个多小时之后，我们终于悟道了。我们可以**从`n`开始往下递减变量，在被递减至 2 时，终止循环**。这样就可以超级有逻辑地节省掉 1\*1 的那轮循环了！我们是天才！

```c
int i = 1;
int Factor = 1;
for (i = n; i >= 2; i--) {
	Factor *= i;
}
```

完美
好像也没那么完美，好像`i=n`这行代码没什么意义？不对，应该是`i`这个变量没意义，我们可以用`n`取代掉所有的`i`变量！又省一笔！

```c
int Factor = 1;
for (; n >= 2; n--) {
	Factor *= n;
}
```

优雅又完美。
我们甚至还省掉`for`语句中的初始动作。
未来的公司能招到我真的是他三生有幸。

（摇晃红酒杯）



















