---
{"tags":["翁恺"],"dg-publish":true,"permalink":"/翁恺计算机入门/5.1 第五周第一讲/","dgPassFrontmatter":true,"created":"2024-07-18T02:09:31.897+08:00","updated":"2024-07-27T12:54:51.437+08:00"}
---

### 5.1.1 for 循环：这是最古老的循环，确实样子看上去有点古怪

让我们通过制作一个**阶乘计算器**来初次认识认识 `for` 语句吧
#####  <b style="color: #5DD0C8;">1 - 阶乘</b>
首先的首先，先让我们来认识**什么是阶乘**。

- 在 c 语言中，阶乘的结构是 **n!** 。
	**n** 是个代号，代表任意一个**数字**；
	**!**  是阶乘的**运算符**。

阶乘的计算方法就是 1 * 2 * 3 * 4 * ... * n ，从 1 开始乘，一直到 n（任意数字）为止：
- 3!  =  1 * 2 * 3  =  6
- 8!  =  1 * 2 * 3 * 4 * ... * 8  =  40320
- 1!  =  1
- 0!  =  0

#####  <b style="color: #5DD0C8;">2 - 测试版阶乘计算器</b>
好了，这样看来的话，阶乘不也就是一个循环而已嘛。我们结合上之前的知识，三下五除二就可以敲出：

```c
int n = 0;

scanf_s("%d", &n);

int i = 1;
int Factor = 1;
while (i <= n) {
	Factor *= i;
	i++;
}
```

很完美，不过 c 语言有另外一种语句类型，可以更简短的表达同样的类型。它就是`for`语句。

#####  <b style="color: #5DD0C8;">3 - 初识 for 语句</b>
使用`for`语句不带任何润色的，直接呈现上方`while`部分的代码的话，会是这样：

```c
int Factor = 1;
int i = 1;
for (i = 1; i <= n; i++) {
	Factor *= i;
}
```

###### <b style="color: #5DD0C8;">3.1 - 基础结构</b> 
```c
for (<初始动作>; <条件>; <循环后做事>) {
	<循环体>;
}
```

我们看到，`for`语句与`while`语句在结构上很相似，但也有不同。它的圆括号中被分割出了**三个区域，用于填上三个表达式**：

- 第一个表达式：代表这个语句的**初始动作**；
	仅在第一次进入`for`语句时运行，但必定运行一次，无论条件是否成立）。

- 第二个表达式：代表进行循环的**条件**
	同`while`的用法。

- 第三个表达式：代表在每一轮之后，会做的事情，无论条件是否成立；
	在第一轮循环结束后才运行。

最后，`for`语句也和`while`语句一样，有一个所属于它的**循环体**。

###### <b style="color: #5DD0C8;">3.2 - 语句逻辑</b> 

```c
int Factor = 1;
int i = 1;
for (i = 1; i <= n; i++) {
	Factor *= i;
}
```

该语句逻辑如下（设`n`为 2）：

1. 执行初始动作（将 1 赋值给 `i`）；
2. 第一次判断条件，条件成立；
3. 执行循环体
4. 执行最右边的表达式（递增`i`）；
5. 第二次判断条件，条件成立；
6. 执行循环体；
7. 执行最右边的表达式（递增`i`）；
8. 第三次判断条件，条件不成立，跳出循环。

###### <b style="color: #5DD0C8;">3.3 - 概括与翻译</b> 
整体概括下来，感觉`for`语句就像一个带计数功能的循环。我们可以为这个循环专门建立一个变量，并给它赋上一个值，等同于需要它需要循环的次数。之后我们再初始化一个变量，让它一定调整，等到这个值等于前面那个，循环停止。

如果要更浅显地理解这个语句，我们可以把`for`语句翻译成 “**对于**”：**对于**（一开始的`i = 1`），**当**（`i <= n`）**时，执行循环体。最后，执行**（`i++`）**，并再次检测条件是否成立**。

#####  <b style="color: #5DD0C8;">4 - 套路：在求积的时候就不能把变量初始化成 0 了哦</b>
不知道你有没有注意到，在之前的代码中，我们把`Factor`和`i`初始化成了 1，而不是 0。这是因为它们是被用来进行乘法的，如果初始化成 0 的话，这个代码就会沉入 0 号空洞，永不见天日，这辈子都找不到它的 1，和更大的数字了（0 * 10086  =  0）。

#####  <b style="color: #5DD0C8;">5 - 阶乘计算器的优化</b>
好啦，在了解清楚更高级更优雅的解题方法之后，现在是优化时间！
###### <b style="color: #5DD0C8;">5.1 - 将变量初始化塞进 for 语句中</b> 
```c
int Factor = 1;
for (int i = 1; i <= n; i++) {
	Factor *= i;
}
```

程序其实可以被缩短成这样。我们把定义`i`变量的语句塞进了`for`语句的第一个表达式中，我们选择这么做是因为两点：

1. `i`变量在`for`语句外是用不到的：
	`i`在这个程序中只起到阶乘的递增作用，所以我们即使这么做也不会让整个程序难以理解。一样的道理，我们不能对在`for`语句外也有用的`Factor`做这事。

2. Visual Studio 2022 支持这种编译方式：
	这种编译方式是 C99 专有的，不过即使是一些支持 C99 的编译软件也不支持这种编译方式（但 Visual Studio 2022 恰好就支持这种编译方式）。

###### <b style="color: #5DD0C8;">5.2 - 将 i 赋值为 2，节省一轮循环</b> 
```c
int Factor = 1;
int i = 1;
for (i = 2; i <= n; i++) {
	Factor *= i;
}
```

在这之前，我们知道在求积的过程中，1 * 1可以说是没太多意义的。1 * 1 * 2 与 1 * 2 的结果完全相等，但在这个程序中，前者却比后者**多一轮循环**，但是勤（kou）俭（kou）持（sou）家（sou）、以性能为天的程序员们对此完全接受无能！！！

为此，我们把`for`语句的初始动作改为了`i=2`，一眼看上去好多了。不过在这背后，还有个**隐藏的危险：**`n`=1。

当`n`=1 时，`i`被初始动作赋值成 2 。此时的`i`要大于`n`，循环条件将会**不成立**，`Factor`将会以它的初始值被输出！！

但在这个例子下，`n`=1 情况的标准答案刚好就是 1，也就是`Factor`的初始值，所以我们还真可以这么操作，以剩下一个循环的性能。

不过，在接下来的章节，我们将会推敲出一个最完美的阶乘计算器。它也可以帮我们省掉 1 * 1 的那一次循环，且没有任何运气成分。

#####  <b style="color: #5DD0C8;">6 - 宇宙无敌暴龙EX · 完美 · 阶乘计算器</b>
总感觉这个程序还能继续优化……这个时候，我们可以试着**换位**思考一下。

在一起倒立三个多小时之后，我们终于悟道了。我们可以**从`n`开始往下递减变量，在被递减至 2 时，终止循环**。这样就可以超级有逻辑地节省掉 1\*1 的那轮循环了！我们是天才！

```c
int i = 1;
int Factor = 1;
for (i = n; i >= 2; i--) {
	Factor *= i;
}
```

完美
好像也没那么完美，好像`i=n`这行代码没什么意义？不对，应该是`i`这个变量没意义，我们可以用`n`取代掉所有的`i`变量！又省一笔！

```c
int Factor = 1;
for (; n >= 2; n--) {
	Factor *= n;
}
```

优雅又完美。
我们甚至还省掉`for`语句中的初始动作。
未来的公司能招到我真的是他三生有幸。

（摇晃红酒杯）


### 5.1.2 循环的计算与选择：如何计算循环的次数、如何选择不同的循环

#####  <b style="color: #5DD0C8;">1 - for 循环深究：循环次数 - 变量变化</b>
我们通常会在程序需要一个循环，且那个循环需要执行指定次数的时候选择`for`循环。

```c
for(i=0; i<n; i++)
```
这样的一个循环由`i`和`n`两个变量组成。意义为：
	在开始的时候将0赋值给`i`，
	然后检测条件是否成立：
		若是，先执行循环体再执行第三语句，最后循环；
		若否，跳出语句。

不过，除了运算顺序外，**`i`和`n`在程序运算中变化的过程**也是很重要的：

- 如果代码如上`for(i=0; i<n; i++);`，那么它的循环次数将会是`n`次；在跳出循环时，循环的控制变量`i`的值也将等于`n`。过程如下（设`n`=5）：

```c
for (i = 0; i < n; i++)
	printf("i = %d ", i);

printf("\n最后，i = %d\n", i);
```
```
i=0 i=1 i=2 i=3 i=4
最后，i=5
```


- 但是，如果代码变为`for(i=1; i<=n; i++);`，它的循环次数依然会是`n`次；但在跳出循环时，`i`的值会是`n`+1：
```
i=1 i=2 i=3 i=4 i=5
最后，i=6
```


#####  <b style="color: #5DD0C8;">2 - for 循环与 while 循环间的相互性</b>
我们观察下方的两块代码：

```c
for( int i = 1; i<n; i++)
	fact *= 1;
```

```c
int i = 1;
while ( i<n ) {
	fact *= 1;
	i++;
}
```

前者是一块`for`循环；后者是一块`while`循环，但它们做的事是完完全全一样的。从此，我们也可以悟出将`for`循环改写成`while`循环的道理：
	将`for`循环的第一个表达式放到`while`之前；
	将`for`循环的第二个表达式放到`while`的条件圆括号中；
	将`for`循环的第三个表达式放到`while`循环体的最后。

**所有的`for`循环都能这样被改写成`while`循环（但这并不意味着所有的`while`都能被改成`for`！！！）。**

**那些只有一段循环体的`while`循环才能被改写成`for`循环**。因为`for`循环中三个表达式中的**每一个都是可以被省略的**。只需要这样：

```c
while (i<n) {
	i *= 1;
}
```

```c
for (;i<n;)
	i *= 1;
```

**`for`循环的分号是不可以省略的！！！**

#####  <b style="color: #5DD0C8;">3 - 如何选择循环</b>
目前，我们认识了三种循环，它们分别是`for`、`while`和`do-while`。一般来说，选择的思路如下：

- 当需要循环指定的次数时，使用`for`（如阶乘）；
- 当必须执行一次循环体时，使用`do-while`；
- 其它情况，使用`while`。

### 5.2.1 循环控制：如何用 break 和 continue 来控制循环

#####  <b style="color: #5DD0C8;">1 - 素数验证器</b>
**题目**
读入一个数，并判断读入的这个数是不是一个素数。
	素数：只能被 1 或者自己整除的数。

我自己捣鼓的笨蛋式素数验证器在文章末尾。虽然能用，但不具备任何参考意义，只有很足的娱乐性质和嘲笑性质（尽管是苦心研究两个小时之后的产物）（有备注）。

我们还是看看远处翁恺老师写的版本吧（）。







































***
**哇呼呜自研素数验证器**
```c
int n = 0
int d = 2;

if (n == 1) {
}
else {
	// 使用 t 来录入取余。
	//		若 t != 0，不是整除，继续循环；
	//		否则，跳出循环。
	for (int t = 10086; t != 0; d++)
		t = n % d;
}

// 使用 if 语句观察跳出语句时 d 是否等于 n。
//		若等于，代表 t 在循环中一直不被整除，是素数；
//		否则，代表 t 有被整除过，不是素数。
//d-1是因为在循环的最后还会进行一次 d++，这里得减回去。但我最好得想个更有逻辑一点的版本。
if (d-1 == n) {
	printf("\n该数字是素数。");
}
else {
	printf("\n该数字不是素数。");
}
```








